# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dNU4856TNVszO6LecHg6H11BU6aefsov
"""

#Best first search

from collections import defaultdict

class Graph:
  def __init__(self):
    self.g = defaultdict(list)
    self.h = {}

  def addh(self,v,value):
    self.h[v]=value

  def addedge(self,u,v):
    self.g[u].append(v)
    self.g[v].append(u)

  def pgraph(self):
    print(self.g)
    print(self.h)

  def bfs(self,start,goal):
    opened,closed = [],[]
    opened.append(start)
    while opened:
      t = opened.pop(0)
      closed.append(t)
      if t == goal: print("Goal found"); print(opened, " ", closed); return 1
      for i in self.g[t]:
        if i not in closed:
          opened.append(i)
      opened.sort(key = lambda x: self.h[x])
      print(opened, " ", closed)
    print("Not found")


if __name__=='__main__':

  g = Graph()
  n = int(input("no.of nodes???"))
  m = int(input("no.of edges???"))
  for i in range(m):
    u,v = input().split()
    g.addedge(u,v)
  for i in range(n):
    li = list(map(str,input().split()))
    g.addh(li[0],int(li[1]))

  #g.pgraph()
  g.bfs('a','e')

#bi-directional

from collections import defaultdict

class Graph:
  def __init__(self):
    self.g = defaultdict(list)
    self.c1,self.c2 = [],[]

  def addedge(self,u,v):
    self.g[u].append(v)
    self.g[v].append(u)

  def bidirectional(self,start,goal):
    o1,o2 = [],[]
    o1.append(start)
    o2.append(goal)
    while o1 and o2:
      t1 = o1.pop(0)
      self.c1.append(t1)
      t2 = o2.pop(0)
      self.c2.append(t2)
      for i in self.g[t1]:
        if i not in self.c1:
          o1.append(i)
      for i in self.g[t2]:
        if i not in self.c2:
          o2.append(i)
      for i in o1:
        if i in o2:print(o1, " ", self.c1, " ", o2, " ", self.c2); print('Goal Found'); return
      print(o1, " ", self.c1, " ", o2, " ", self.c2)
    print("Not found")

g = Graph()
n = int(input("No.of edges...."))
for i in range(n):
  u,v = input().split()
  g.addedge(u,v)
start, goal = input().split()
g.bidirectional(start,goal)



#Hillclimbing

from collections import defaultdict

class Graph:
  def __init__(self):
    self.g = defaultdict(list)
    self.h = {}

  def addh(self,v,value):
    self.h[v]=value

  def addedge(self,u,v):
    self.g[u].append(v)
    self.g[v].append(u)

  def pgraph(self):
    print(self.g)
    print(self.h)

  def hill(self,start,goal):
    opened,closed = [],[]
    opened.append(start)
    while opened:
      t = opened.pop(0)
      closed.append(t)
      li = []
      opened.sort(key = lambda x: self.h[x])
      if t == goal: print("Goal found"); print(opened, " ", closed); return 1
      for i in self.g[t]:
        if i not in closed+opened:
          li.append(i)
      opened = li + opened
      print(opened, " ", closed)
    print("Not found")


if __name__=='__main__':

  g = Graph()
  n = int(input("no.of nodes???"))
  for i in range(n):
    li = list(map(str,input().split()))
    g.addh(li[0],int(li[1]))
  m = int(input("no.of edges???"))
  for i in range(m):
    u,v = input().split()
    g.addedge(u,v)

  #g.pgraph()
  u,v = input("Enter start and goal states: ").split()
  g.hill(u,v)